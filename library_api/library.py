import os
import requests
import html.entities
from flask import Blueprint, request, jsonify
from library_api.database import get_db

def error_message(message='Incorrect parameters'):
    return jsonify({'error': message})

"""
Substitutes a string's non-ASCII characters by their equivalent character entities.
It also replaces spaces by plus signs, as requested by the book cover API.
Proposed and generated by ChatGPT
"""
def convert_to_html_entities(text: str):
    result = []
    for char in text:
        # Check if the character is ASCII
        if ord(char) < 128:
            result.append(char)
        else:
            # Attempt to find a named HTML entity for the character
            entity_name = html.entities.codepoint2name.get(ord(char))
            if entity_name:
                # Use the named entity (e.g., &euml; for Ã«)
                result.append(f"&{entity_name};")
            else:
                # Use a numeric entity if no named entity exists
                result.append(f"&#{ord(char)};")
    return ''.join(result).replace(' ', '+')

bp = Blueprint('library_api', __name__)

# Returns a dictionary with basic book info by ID
def basic_book_info(book_id: int):
    db = get_db()
    book = db.execute(
        '''
        SELECT tbook.cTitle AS title, trim(tauthor.cName || ' ' || tauthor.cSurname) AS author,
            tpublishingcompany.cName AS publishing_company, tbook.nPublishingYear AS publishing_year
        FROM tbook
            INNER JOIN tauthor
                ON tbook.nAuthorID = tauthor.nAuthorID
            INNER JOIN tpublishingcompany
                ON tbook.nPublishingCompanyID = tpublishingcompany.nPublishingCompanyID
        WHERE tbook.nBookID = ?
        ''',
        (book_id,)
    ).fetchone()
    
    if book == None:
        return error_message('Book not found'), 404
    else:        

        # The book title is obtained from the book cover API
        book_cover_base_url = os.getenv('BOOK_COVER_BASE_URL')
        book_title = convert_to_html_entities(book['title'])
        author_name = convert_to_html_entities(book['author'])
        book_cover_url = f'{book_cover_base_url}?book_title={book_title}&author_name={author_name}'
        result = dict(requests.get(book_cover_url).json())
        if 'error' in result:
            cover = ''
        else:
            cover = result['url']

        # The sqlite row is converted to a dictionary
        book_info = {key: book[key] for key in book.keys()}
        book_info['cover'] = cover
        return book_info

# Return basic book info by ID 
@bp.route('/books/<int:book_id>', methods=['GET'])
def get_book(book_id: int):
    book_info = basic_book_info(book_id)
    if 'error' in book_info:
        return book_info, 404
    else:
        return jsonify(book_info), 200

# Return detailed book info by ID 
@bp.route('/admin/books/<int:book_id>', methods=['GET'])
def get_detailed_book(book_id: int):
    db = get_db()
    book_info = basic_book_info(book_id)
    if 'error' in book_info:
        return book_info, 404
    else:
        loans = db.execute(
            '''
            SELECT nMemberID AS user_id, dLoan AS loan_date
            FROM tloan
            WHERE nBookID = ?
            ORDER BY dLoan
            ''',
            (book_id,)
        ).fetchall()

        # The loan date is converted to a string, but the user ID is not
        loan_list = [{key: str(loan[key]) if key == 'loan_date' else loan[key] \
            for key in loan.keys()} for loan in loans]
        book_info['loans'] = loan_list
        return jsonify(book_info), 200
    
# Return random book info
@bp.route('/books', methods=['GET'])
def get_random_books():
    number = request.args.get('n')
    if number == None:
        return error_message()
    else:
        db = get_db()
        books = db.execute(
            '''
            SELECT tbook.nBookID AS book_id, tbook.cTitle AS title, tbook.nPublishingYear AS publishing_year,
                trim(tauthor.cName || ' ' || tauthor.cSurname) AS author, tpublishingcompany.cName AS publishing_company
            FROM tbook INNER JOIN tauthor
                    ON tbook.nAuthorID = tauthor.nAuthorID
                INNER JOIN tpublishingcompany
                    ON tbook.nPublishingCompanyID = tpublishingcompany.nPublishingCompanyID
            ORDER BY RANDOM()
            LIMIT ?
            ''',
            (number,)
        ).fetchall()

        book_list = [{key: book[key] for key in book.keys()} for book in books]
        return jsonify(book_list), 200
    
# Return user information
@bp.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id: int):
    db = get_db()
    user = db.execute(
        '''
        SELECT cEmail AS email, cName AS first_name, cSurname AS last_name, 
            cAddress AS address, cPhoneNo AS phone_number, 
            dBirth AS birth_date, dNewMember AS membership_date
        FROM tmember
        WHERE nMemberID = ?
        ''',
        (user_id,)
    ).fetchone()

    if user == None:
        return error_message('User not found'), 404
    else:        
        user_info = {key: user[key] for key in user.keys()}
        user_info['birth_date'] = str(user_info['birth_date'])
        user_info['membership_date'] = str(user_info['membership_date'])
        return jsonify(user_info), 200
